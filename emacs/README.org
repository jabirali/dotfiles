#+TITLE: Emacs configuration
#+AUTHOR: Jabir Ali Ouassou

* Emacs
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/.config/emacs/init.el
:END:
This is my configuration for Emacs 29+ @ macOS. My setup is based around =org-mode= and =evil-mode=; I mostly use Emacs for Org-mode and and Vim for programming, this setup keeps them mostly interchangeable.

** Package management
Bootstrap the Emacs package manager. Specifically, I want to prevent it from polluting my dotfiles with third-party packages, and I want to ensure that the community package repositories are available.
#+begin_src emacs-lisp
  (require 'package)
  (setq package-user-dir "~/.cache/emacs/elpa")
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
#+end_src

Since Emacs 29, =use-package= has been included in the base distribution. This is a vastly better way to configure Emacs than manually wrangling packages, hooks, keybindings, etc. This configuration file is therefore structured as much as possible in terms of =use-package= statements.
#+begin_src emacs-lisp
  (use-package use-package
    :custom
    (use-package-always-demand t)
    (use-package-always-ensure t))
#+end_src

Many Emacs packages throw their cache files in =~/.config/emacs/= by default, which is very annoying when that directory is kept under version control. Luckily, =no-littering= can help us tame those packages.
#+begin_src emacs-lisp
  (use-package no-littering
    :config
    ;; Set nearly all cache files to follow the XDG specification.
    (setq user-emacs-directory (expand-file-name "~/.cache/emacs/"))
    (setq no-littering-var-directory user-emacs-directory)
    (setq no-littering-etc-directory user-emacs-directory)
    ;; Also move the backup~ and #auto-save# files out of the way.
    (no-littering-theme-backups)
    ;; Customizations are host-specific and not suitable for dotfiles.
    (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
    (load custom-file))
#+end_src

As of Emacs 29, there is no easy way to install Emacs packages directly from GitHub. The best workarounds are [[https://github.com/slotThe/vc-use-package][vc-use-package]] or [[https://github.com/quelpa/quelpa-use-package][quelpa-use-package]]. However, [[https://tony-zorman.com/posts/use-package-vc.html][in Emacs 30]], there is a =:vc= keyword for =use-package= coming. So if you start relying on GitHub packages, consider just upgrading to v30.

** Built-in packages
The Emacs defaults are quite dated. This makes it fit in the 2020s.
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (inhibit-startup-message t)
    (use-short-answers t)
    (truncate-lines t)
    (line-spacing 0.15)
    (sentence-end-double-space nil)
    :custom-face
    (default ((t (:family "JetBrains Mono NL" :height 140))))
    :config
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (blink-cursor-mode -1)
    (fringe-mode -1)
    (setq ring-bell-function 'ignore))
#+end_src

Emacs recently added a tab bar which works similarly to Vim or Tmux, i.e. each tab corresponds to a numbered "window configuration" that you can easily switch between. Moreover, it can record a per-tab history of recent window configurations, similarly to a web browser.
#+begin_src emacs-lisp
  (use-package tab-bar
    :custom
    (tab-bar-show 1)
    (tab-bar-close-button-show nil)
    (tab-bar-new-tab-choice "*scratch*")
    (tab-bar-tab-hints t)
    (tab-bar-select-tab-modifiers '(super))
    (tab-bar-format '(tab-bar-format-tabs))
    (frame-title-format "")
    :config
    (tab-bar-mode 1))
#+end_src

Code folding with =outline-minor-mode=. This is the package that =org-mode= is built on, and it integrates well with =evil-mode=. Note that any keybindings need to be bound in the ='local= (major mode) map to prevent it from breaking Magit. I'll do that when loading/configuring the specific programming modes below.
#+begin_src emacs-lisp
  (use-package outline
    :custom
    (outline-blank-line t))
#+end_src

I want Emacs to remember my recently used files and commands.
#+begin_src emacs-lisp
  (use-package recentf
    :config
    (recentf-mode 1))

  (use-package savehist
    :config
    (savehist-mode 1))
#+end_src

Finally, let's start the Emacs daemon by default. This lets us quickly connect to the running Emacs instance from a terminal via =emacsclient=.
#+begin_src emacs-lisp
  (use-package server
    :config
    (server-mode 1))
#+end_src

** Helper functions
These are various helper functions used throughout my config.
#+begin_src emacs-lisp
  (defun +open-file (file &optional dir)
    "Create an interactive command for opening a given file.

  If a directory is provided, we look for the file there."
    `(lambda ()
       (interactive)
       (if (null ,dir)
           (find-file (expand-file-name ,file))
                      (find-file (expand-file-name ,file ,dir)))))

  (defun +close-window ()
    "Close window. If it's the last window, close the whole tab."
    (interactive)
    (if (one-window-p)
        (tab-bar-close-tab)
      (delete-window)
      (balance-windows)))

  (defun +kill-buffer-and-close-window ()
    "Kill buffer and then close the currently active window."
    (interactive)
    (kill-buffer)
    (+close-window))
#+end_src

#+begin_src emacs-lisp
  (defun +insert-date ()
    "Insert an ISO date stamp corresponding to today."
    (interactive)
    (insert (format-time-string "%Y-%m-%d %A")))
#+end_src

** User interface
External packages that gives Emacs a modern look (inspired by Doom).
#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-buffer-modification-icon nil)
    (doom-modeline-icon nil)
    (doom-modeline-modal nil)
    (doom-modeline-position-line-format nil)
    (doom-modeline-time nil)
    (doom-modeline-workspace-name nil)
    :config
    (doom-modeline-mode))

  (use-package spacious-padding
    :config
    (spacious-padding-mode))

  (use-package doom-themes
    :config
    (load-theme 'doom-oksolar-light t)

    ;; Make tabs and dividers match the mode-line.
    (let ((bg  (face-attribute 'mode-line :background))
          (box (face-attribute 'mode-line :box)))
      (set-face-attribute 'tab-bar nil :background bg :box box)
      (set-face-attribute 'tab-bar-tab-inactive nil :background bg :box box)
      (set-face-attribute 'tab-bar-tab nil :background bg :box box :weight 'bold)
      (set-face-attribute 'vertical-border nil :background bg :foreground bg)))
#+end_src

** User experience
Packages for enabling fuzzy-finding across the Emacs user interface.
#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode)
    (vertico-mouse-mode)
    (vertico-reverse-mode))

  (use-package consult
    :after vertico)

  (use-package marginalia
    :after vertico
    :config
    (marginalia-mode))

  (use-package orderless
    :config
    (setq completion-styles '(orderless)))
#+end_src

Better workflow for switching between visible windows.
#+begin_src emacs-lisp
  (use-package ace-window
    :bind
    ("M-o" . 'ace-window))
#+end_src

Better integration with Git version control.
#+begin_src emacs-lisp
  (use-package magit
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1))
#+end_src

** Modal editing
I've used Vim keybindings for nearly two decades, and still regularly use it for programming or quick remote edits. Moreover, every time I've tried to switch to Emacs keybindings, my RSI has flared up. So for me, =evil-mode= is a prerequisite for using Emacs at all.
#+begin_src emacs-lisp
  (use-package evil
    :custom
    (evil-want-keybinding nil)
    (evil-want-integration t)
    (evil-want-C-u-scroll t)
    :config
    (evil-mode 1))
#+end_src

Evil is great, but by default it only works in text-editing modes. This makes it work across nearly all Emacs modes and packages.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

Org-mode is a different beast, and requires some extra integration to work well with Evil. Note that =evil-org-agenda= is provided by =evil-org=, it's for some reason just not activated by default.
#+begin_src emacs-lisp
  (use-package evil-org
    :after (evil org)
    :config
    (general-evil-define-key 'normal 'org-mode-map
      "RET" 'org-open-at-point)
    :hook
    (org-mode . evil-org-mode))

  (use-package evil-org-agenda
    :ensure nil
    :after evil-org
    :config
    (evil-org-agenda-set-keys))
#+end_src

Some Vim plugins are also worth taking with us into Emacs.
#+begin_src emacs-lisp
  (use-package evil-surround
    :ensure t
    :config
    (global-evil-surround-mode 1))
#+end_src 

** Global menu
I like the "space menu" that is provided by default in e.g. Spacemacs and Doom Emacs. This is my personalized version of this concept.
#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))

  (use-package general
    :after evil
    :config
    (general-override-mode)
    (general-create-definer +leader-map
      :keymaps 'override
      :states '(motion normal visual)
      :prefix "SPC")

    ;; Global leader mappings.
    (+leader-map
      ;; Important.
      "SPC" '(execute-extended-command :which-key "command")
      "TAB" '(ace-window :which-key "switch")
      "RET" '(scratch-buffer :which-key "scratch")

      ;; Existing keymaps.
      "h" `(,help-map :which-key "+help")

      ;; Common actions.
      "s" '(save-buffer :which-key "save")
      "t" '(tab-bar-new-tab :which-key "tab")
      "w" '(+close-window :which-key "close")
      "d" '(split-window-below :which-key "split")
      "q" '(+kill-buffer-and-close-window :which-key "quit")
      "Q" '(server-edit :which-key "done")
      "g" '(magit :which-key "git")

      ;; Bookmarks.
      "m" '(bookmark-set :which-key "set mark")
      "'" '(bookmark-jump :which-key "goto mark")

      ;; Reserved for major modes.
      "e" '(:ignore t :which-key "eval")

      ;; Tab switching.
      "1" '(tab-bar-select-tab :which-key "1")
      "2" '(tab-bar-select-tab :which-key "2")
      "3" '(tab-bar-select-tab :which-key "3")
      "4" '(tab-bar-select-tab :which-key "4")
      "5" '(tab-bar-select-tab :which-key "5")
      "6" '(tab-bar-select-tab :which-key "6")
      "7" '(tab-bar-select-tab :which-key "7")
      "8" '(tab-bar-select-tab :which-key "8")
      "9" '(tab-bar-select-tab :which-key "9")

      ;; Insert stuff.
      "i" '(:ignore t :which-key "insert")
      "id" '(+insert-date :which-key "date")

      ;; Open stuff.
      "o" '(:ignore t :which-key "open")
      "o o" '(switch-to-buffer :which-key "buffer")
      "o ." `(,(+open-file "~/.config/emacs/README.org") :which-key "dotfile")
      "o a" '(org-agenda :which-key "agenda")
      "o d" '(dired-jump :which-key "directory")
      "o f" '(find-file :which-key "file")
      "o i" `(,(+open-file "inbox.org" 'org-directory) :which-key "inbox")
      "o j" `(,(+open-file "journal.org" 'org-directory) :which-key "journal")
      "o k" '(org-capture :which-key "capture")
      "o p" '(project-find-file :which-key "project")
      "o r" '(recentf :which-key "recent"))

    ;; Major-mode mappings.
    (+leader-map emacs-lisp-mode-map
                "e e" '(eval-buffer :which-key "buffer")
                "e d" '(eval-defun :which-key "defun")))
#+end_src

** Org mode
Emacs =org-mode= is my favorite note-taking app.
#+begin_src emacs-lisp
  (use-package org
    :hook
    (org-mode . visual-line-mode)
    :bind
    (:map org-mode-map
          ("M-p" . org-priority)
          ("M-t" . org-set-tags-command))
    :custom
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
       (sequence "WAIT(w)" "HOLD(h)" "IDEA(*)" "|" "NOTE(-)" "STOP(s)")))
    (org-directory "~/Sync/Org")
    (org-agenda-files (list org-directory))
    (org-archive-location "::* Archive")
    (org-ctrl-k-protect-subtree t)
    (org-image-actual-width '(400))
    (org-pretty-entities t)
    (org-startup-folded 'content)
    (org-startup-indented t)
    (org-startup-with-inline-images t)
    (org-tags-column -65)
    :config
    (defun +url-handler-zotero (link)
      "Open a zotero:// link in the Zotero desktop app."
      (start-process "zotero_open" nil "open" (concat "zotero:" link)))
    (org-link-set-parameters "zotero" :follow #'+url-handler-zotero))
#+end_src

This lets me copy-paste images into my Org notes. Especially useful for keeping a research journal, as it lets me paste important plots into my daily log. (Workflow inspired by Logseq.)
#+begin_src emacs-lisp
  (use-package org-download
    :after org
    :custom
    (org-download-method 'directory)
    (org-download-image-dir "assets")
    (org-download-timestamp "%Y%m%d%H%M%S")
    (org-download-screenshot-basename ".png")
    :config
    (setq org-download-annotate-function (lambda (_link) ""))
    (org-download-enable)
    :bind (:map org-mode-map
                ("M-v" . org-download-clipboard)))

#+end_src

The "scratch buffer" is a nice place to dump random thoughts like the plan for the day -- especially if it's set to use Org-mode as its format. It's a bit risky though, as if Emacs is restarted for any reason (e.g. config updates), everything in the scratch buffer is lost. This fixes that.
#+begin_src emacs-lisp
  (use-package persistent-scratch
    :after org
    :custom
    (initial-major-mode 'org-mode)
    (initial-scratch-message "#+TITLE: Scratch buffer\n")
   :config
    (persistent-scratch-setup-default)
    (persistent-scratch-autosave-mode))
#+end_src

** Programming
I mostly do programming in Vim these days, and am at the moment trying to re-adopt Emacs first and foremost for Org-mode. However, it's still nice to have a decent Emacs setup for reading code while taking Org notes.
#+begin_src emacs-lisp
  (use-package python
    :after (outline evil general)
    :config
    (defun +outline-python ()
      "Fold Python code like Org-mode headings."
      ;; Only fold definitions and decorators (not e.g. loops and conditions).
      (setq outline-regexp
            (rx (or
                 (group (group (* space)) bow (or "class" "def") eow)
                 (group (group (* space)) "@"))))
      ;; Org-mode-like keybindings for cycling through outline states.
      (evil-define-key 'motion 'local (kbd "<tab>")
        (general-predicate-dispatch nil (derived-mode-p  'prog-mode) 'outline-cycle))
      (evil-define-key 'motion 'local (kbd "<backtab>")
        (general-predicate-dispatch nil (derived-mode-p 'prog-mode) 'outline-cycle-buffer))
      ;; Enable the mode.
      (outline-minor-mode 1))
    :hook
    (python-mode . +outline-python))
#+end_src

** Operating system
In my experience, the [[https://bitbucket.org/mituharu/emacs-mac/src/master/][Emacs Mac port]] remains the best option for macOS. For instance, it has the best handling of Retina (hiDPI) screens. Unfortunately, installing it from source is required to enable some features (notably native compilation), but at the same time breaks some other features (e.g. starting the Emacs GUI from a terminal). I'm therefore sticking to the precompiled Cask for now.
#+begin_src bash
  brew tap "railwaycat/emacsmacport"
  brew install --cask emacs-mac
#+end_src bash
    
These tweaks makes the app look a bit nicer when using =tab-bar-mode=.
#+begin_src bash
  defaults write org.gnu.Emacs TransparentTitleBar DARK
  defaults write org.gnu.Emacs HideDocumentIcon YES
#+end_src

Emacs doesn't know my shell environment variables when started as a GUI, and those variables end up affecting =emacsclient= processes that are launched from a terminal later. This is a workaround whereby macOS is told to set those environment variables globally.
#+begin_src xml :tangle ~/Library/LaunchAgents/environment.plist
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
      <key>Label</key>
      <string>Environment</string>
      <key>ProgramArguments</key>
      <array>
          <string>sh</string>
          <string>-c</string>
          <string>launchctl setenv COLORTERM truecolor</string>
      </array>
      <key>RunAtLoad</key>
      <true/>
  </dict>
  </plist>
#+end_src

* Export
This code ensures that this config is automatically exported to elisp and then evaluated in full whenever the file is saved within Emacs.
#+begin_src
Local Variables:
    eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle) (load-file user-init-file)) nil t)
End:
#+end_src

