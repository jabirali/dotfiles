#+title: Emacs configuration
#+author: Jabir Ali Ouassou
#+PROPERTY: header-args:emacs-lisp :tangle "init.el"

* Tasks
This section is for planned maintenance tasks for my Emacs config.

** TODO Make a reproducible config
- Store =package.el= packages (including =el= and =elc= files, excluding =eln=, =so=, =dylib= files) in my Git dotfiles repo. That way, the exact same package versions are used remotely as well.
- Move to =straight.el= that supports lockfiles (via its =freeze= / =thaw= mechanism).
- Move to =elpaca= that supports ultrafast parallelized bootstrap remotely.
- Remove the =ensure t= flags if I do add all my packages to Git.

** TODO Improve the performance
I've already toggled on =defer= as default for =use-package=. Perhaps I can still do better, by e.g. making things toggle on =after-init-hook= that don't need usage immediately? Or reducing some =use-package= blocks to simple =setopt= if I don't actually need to use the package at boot? Etc?
** TODO Consider better modifiers
On Apple keyboards, a lower-left {Fn, Ctrl, Opt, Cmd} mapped to {Hyper, Super, Meta, Ctrl} makes sense.

** TODO Make some =general.el= code into a module
Especially the code that just remaps =C-c C-...= into =, ...= is well-suited for a module.

** TODO Look into =speed-rect=
Makes rectangle selections more useful. See [[https://github.com/jdtsmith/speedrect]].

* [100%] Installation
** DONE Mac port
The "Mac port" integrates well with MacOS, including full Retina support and better trackpad support. But it doesn't work as well as the [[NS port]] in the terminal and updates are usually slower.

To build it from source (to get native compilation and a nicer icon):
#+begin_src sh
  brew tap railwaycat/emacsmacport
  brew install emacs-mac \
      --with-native-compilation --with-emacs-big-sur-icon --with-natural-title-bar
#+end_src

To install the pre-built version (slower but less chance of problems):
#+begin_src sh
  brew tap railwaycat/emacsmacport
  brew install --cask emacs-mac
#+end_src

** DONE NS port
The "NextStep port" is the official GNU Emacs release. This means that it's updated more often and more similar across OS versions. I prefer the patched "Emacs Plus" version, which can be fetched via HomeBrew:
#+begin_src sh
  brew tap d12frosted/emacs-plus
  brew install emacs-plus@30 --with-native-comp --with-nobu417-big-sur-icon 
#+end_src

On Intel MacBooks that can't (or are too slow for) the latest version of MacOS, the best option is to fetch the prebuilt version from [[https://emacsformacosx.com/][EmacsForMacOSX.com]]. That way, you don't need to compile every single dependency.

** DONE Linux
On an up-to-date Ubuntu system, the newest major version is usually in the main repos:
#+begin_src sh
  sudo apt install emacs
#+end_src

On outdated servers, it might be better to fetch a recent build from =conda-forge=:
#+begin_src sh
  conda install -n base -c conda-forge emacs
#+end_src

* [22%] Basic settings
** DONE Packages
Before we install anything else, let's enable the community repositories and turn on native compilation.
#+begin_src emacs-lisp
  (use-package use-package
    :custom
    (package-native-compile t)
    (native-comp-async-report-warnings-errors nil)
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
#+end_src

Note that we don't turn on the common =use-package-always-demand= and =use-package-always-ensure= settings anymore. The former slows down the start-up quite significantly, and the latter is less reproducible and reversible than handling package installations manually and then syncing the =elpa= directory via Git.

In the future, it might be better to migrate to e.g. =straight.el= or =elpaca= for a more seamless sync of package versions between different hosts. For now, I prefer to use the built-in packages when adequate.

** DONE No littering
First of all, let's prevent Emacs from littering my =init.el= file with autogenerated stuff, including the package installation list. Note that this must be set early in the init process to take effect.
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (ignore-errors (load custom-file))
#+end_src

The =no-littering= package does a good job of keeping everything else out of the way.
#+begin_src emacs-lisp
  (use-package no-littering
    :config
    (no-littering-theme-backups))
#+end_src

** TODO Sane defaults
Here's a hodgepodge of built-in Emacs settings. Many of them just try to get rid of anachronisms.
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (auto-save-default nil)
    (default-input-method 'TeX)
    (default-transient-input-method 'TeX)
    (inhibit-startup-echo-area-message "jabirali")
    (dired-listing-switches "-hlLgG --group-directories-first --time-style=long-iso")
    (frame-title-format "GNU Emacs")
    (fringes-outside-margins t)
    (inhibit-startup-message t)
    (initial-major-mode 'org-mode)
    (initial-scratch-message "")
    (line-spacing 0.15)
    (make-backup-files nil)
    (message-truncate-lines t)
    (ring-bell-function 'ignore)
    (sentence-end-double-space nil)
    (tab-width 4)
    (truncate-lines t)
    (use-short-answers t)
    (xterm-set-window-title t)
    :custom-face
    (default ((t (:family "JetBrains Mono NL" :height 140))))
    :bind
    ("C-\\" . activate-transient-input-method)
    ("<f5>" . sort-lines)
    :config
    ;; Don't indicate long or wrapped lines.
    (set-display-table-slot standard-display-table 'truncation ? )
    (set-display-table-slot standard-display-table 'wrap ? )
    ;; Turn on some useful default modes.
    (global-auto-revert-mode 1)
    (recentf-mode 1)
    (savehist-mode 1)
    ;; Disable the annoying default modes.
    (blink-cursor-mode -1)
    (menu-bar-mode -1)
    (when (display-graphic-p)
      (fringe-mode 1)
      (tooltip-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)))
#+end_src

Let's also increase the garbage collection threshold a bit. This makes Emacs stutter a bit less and speeds up the start-up process.
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq gc-cons-threshold (* 128 1024 1024)
        read-process-output-max (* 1024 1024))
#+end_src
** TODO Graphical interface
Let's add some extra breathing room around the buffer text.
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq-default left-margin-width 2
                right-margin-width 2)
#+end_src

Let's remove the breathing room around the tab bar and mode line, however. Usually, it's too small too look nice anyway, and it makes the tab bar in particular look a bit "fake" somehow.
#+begin_src emacs-lisp :tangle "early-init.el"
  (add-to-list 'default-frame-alist '(internal-border-width . 0))
#+end_src

When using a tiling window manager, it's annoying when an app decides that it doesn't want to confirm to your "grid". Fix it.
#+begin_src emacs-liso
  (setopt frame-resize-pixelwise t)
#+end_src

I'm tired of manually disabling italics everywhere in Emacs (comments, keywords, etc.) each time I'm trying out new themes. Let's just disable italics globally instead, similarly to the good old monospace terminals.
#+begin_src emacs-lisp
  (set-face-italic-p 'italic nil)
#+end_src

** TODO Terminal interface
The "Kitty Keyboard Protocol" lets you use GUI keybindings in the TUI version of Emacs. Requires the Kitty terminal emulator though.
#+begin_src emacs-lisp
  ;; (use-package kkp
  ;;  :custom
  ;;  (kkp-super-modifier 'meta)
  ;;  :config
  ;;  (global-kkp-mode +1))
#+end_src

These settings enable terminal mouse support and scrolling.
#+begin_src emacs-lisp
  ;; (setopt mouse-wheel-follow-mouse t)
  ;; (setopt mouse-wheel-progressive-speed nil)
  ;; (mouse-wheel-mode 1)
  ;; (xterm-mouse-mode 1)
#+end_src  

This package lets Emacs interact with the system clipboard also when running in a terminal. Despite the name it works on both Linux and MacOS. However, note that so far, this doesn't appear to work with the new =yank-media= command from Emacs 29?
#+begin_src emacs-lisp
  (use-package xclip
    :config
    (xclip-mode 1))
#+end_src

** TODO Mouse and trackpad
It can be quite distracting when the mouse randomly highlights every little clickable thing. Let's just disable that.
#+begin_src emacs-lisp
  (setopt mouse-highlight nil)
#+end_src
  
** TODO Keyboard settings
As an Evil user, I don't really need the Super key available. I do however need an easily accessible Meta key (e.g. for =M-RET= in Org-mode), and I do need an Option key (to type in Norwegian).
#+begin_src emacs-lisp
  (setopt mac-command-modifier 'meta)
  (setopt mac-option-modifier 'option)
#+end_src

I regularly switch between ISO and ANSI style keyboards, which can be quite annoying since the backtick and tilde symbols keep moving around (and I use both of them a lot). Let's fix that.
#+begin_src emacs-lisp
  (define-key key-translation-map (kbd "§") (kbd "`"))
  (define-key key-translation-map (kbd "±") (kbd "~"))
#+end_src

** TODO Emacs server
Run Emacs as a server. I chose to run it over TCP, because this lets me SSH forward the server to remote hosts. When I'm in a remote shell, I can then easily phone home via =emacsclient= to spawn new Tramp connections.
#+begin_src emacs-lisp
  (use-package server
    :custom
    (server-use-tcp t)
    (server-port 1337)
    :config
    (server-mode 1))
#+end_src

* [0%] Keybindings
** TODO Evil itself
First of all, let's enable the "Evil mode". As someone with a Vim background, this is more ergonomic for both my brain and my hands.
#+begin_src emacs-lisp
  (use-package evil
    :custom
    (evil-respect-visual-line-mode t)
    (evil-undo-system 'undo-redo)
    (evil-want-C-i-jump nil)
    (evil-want-C-u-scroll t)
    (evil-want-integration t)
    (evil-want-keybinding nil)
    :config
    (evil-mode 1)
    (define-key evil-motion-state-map (kbd "SPC") nil)
    (define-key evil-motion-state-map (kbd "RET") nil)
    (define-key evil-motion-state-map (kbd "TAB") nil))
#+end_src
** TODO Evil collection
Evil Collection is exactly what is sounds like: It makes Evil work in nearly every corner of Emacs. Note, I might later wish to look into =evil-collection-key-blacklist= to protect keybindings like =M-l= for lower-case word, =gj= to move one visual line down, etc. which I kinda like as they are in stock Evil.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

Let's improve some modes where Evil Collection is inadequate.
#+begin_src emacs-lisp
  (use-package evil-org
    :after (evil org)
    :hook (org-mode . evil-org-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package evil-org-agenda
    :after evil-org
    :config (evil-org-agenda-set-keys))
#+end_src

#+begin_src emacs-lisp
  (use-package evil-tex
    :hook
    (LaTeX-mode . evil-tex-mode))
#+end_src
** TODO Evil extensions
Emacs ports of some useful Vim plugins.
#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src

** TODO Global keybindings
#+begin_src emacs-lisp
  (bind-key* "M-j" 'avy-goto-word-1)
#+end_src

* [0%] Documentation
** TODO Org-mode notes
Org-mode is my favorite task and knowledge management system.  It's no understatement that Org-mode is the main reason I'm using Emacs at all (otherwise I'd probably be using Vim).
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-adapt-indentation nil)
    (org-agenda-files (list org-directory))
    (org-agenda-window-setup 'only-window)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-span 'day)
    (org-agenda-start-on-weekday nil)
    (org-archive-location "::* Archive")
    (org-babel-results-keyword "results")
    (org-confirm-babel-evaluate nil)
    (org-ctrl-k-protect-subtree t)
    (org-directory "~/Sync/Org")
    (org-fontify-quote-and-verse-blocks t)
    (org-highlight-latex-and-related '(native latex script entities))
    (org-image-actual-width '(400))
    (org-pretty-entities t)
    ;;(org-use-sub-superscripts '{})
    (org-pretty-entities-include-sub-superscripts nil)
    (org-return-follows-link t)
    (org-startup-folded 'fold)
    (org-startup-indented t)
    (org-tags-column -65)
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
       (sequence "WAIT(w)" "HOLD(h)" "READ(r)" "IDEA(*)" "|" "NOTE(-)" "STOP(s)")))
    :config
    (setopt org-latex-src-block-backend 'engraved)
    (setopt org-latex-engraved-theme 'ef-melissa-light)
    (setopt org-latex-packages-alist '(("" "microtype" t)))
    (setopt org-latex-hyperref-template "
  \\hypersetup{\n pdfauthor={%a},\n pdftitle={%t},\n pdfkeywords={%k},
   pdfsubject={%d},\n pdfcreator={%c},\n pdflang={%L},\n colorlinks=true}\n")
    (org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
    (org-link-set-parameters "zotero" :follow #'+url-handler-zotero))
#+end_src

I used to use =org-download= to enable copy-paste and drag-and-drop of image attachments into Org files. That is no longer needed, thanks to the =yank-media= command introduced in recent Emacs versions.

Let's support Pandoc export. This is especially useful to generate DOCX files with TeX equations.
#+begin_src emacs-lisp
  (use-package ox-pandoc
    :if (executable-find "pandoc"))
#+end_src

** TODO MarkDown notes
MarkDown is the lingua franca of mark-up languages, and the Emacs mode is great with the right settings.
#+begin_src emacs-lisp
  (use-package markdown-mode
    :config
    (setopt markdown-fontify-code-blocks-natively t)
    (setopt markdown-enable-wiki-links t)
    (setopt markdown-enable-math t))
    ;; :hook
    ;;(markdown-mode . cdlatex-mode)) 
#+end_src

** TODO TeX documents
AUCTeX is the de facto default TeX mode for Emacs. Let's set it up to sync with Skim on MacOS.
#+begin_src emacs-lisp
  (use-package tex
    :custom
    (font-latex-fontify-script nil)
    (TeX-auto-save t)
    (TeX-source-correlate-method 'synctex)
    (TeX-source-correlate-mode t)
    (TeX-source-correlate-start-server t)
    (TeX-view-program-list '(("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
    (TeX-view-program-selection '((output-pdf "Skim")))) 
#+end_src

CDLaTeX is one of the main reasons I love writing LaTeX in Emacs. It's very ergonomic and intuitive after you get used to it, and it works very well in both Org-mode and TeX-mode.
#+begin_src emacs-lisp
  (use-package cdlatex
    :hook
    ((TeX-mode . turn-on-cdlatex)
     (org-mode . turn-on-org-cdlatex)))
#+end_src

** TODO Spell checking
Ispell is the traditional spell checker for Emacs. It supports many backends, but we here use the Hunspell backend since it (i) supports multi-language dictionary combinations, (ii) is supposed to be more accurate for many non-English languages, (iii) has become the de facto standard among other open-source apps (it is e.g. now the default spell checker in Firefox, LibreOffice, etc.). Note that on MacOS, you need to [[https://github.com/wooorm/dictionaries][download]] the appropriate dictionaries and extract them into =~/Library/Spelling=.
#+begin_src emacs-lisp
  (use-package ispell
    :if (executable-find "hunspell")
    :config
    (setq ispell-program-name "hunspell")
    (setq ispell-personal-dictionary (concat user-emacs-directory "ispell"))
    (setq ispell-dictionary "en_US,nb_NO")
    (ispell-set-spellchecker-params)
    (ispell-hunspell-add-multi-dic "en_US,nb_NO"))
#+end_src

Flyspell is a built-in Emacs package that provides incremental as-you-write spell checking. Let's turn it on.
#+begin_src emacs-lisp
  (use-package flyspell
    :after ispell
    :hook
    ((text-mode . flyspell-mode)
     (prog-mode . flyspell-prog-mode)))
#+end_src

The default Flyspell interface and keybinding =C-c $= is not very ergonomic. Especially if you often have to add your own words to the personal dictionary. I'd rather use something based on =completing-read=, such that I can use e.g. Vertico for the correction interface.
#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :bind (:map flyspell-mode-map ("C-;" . flyspell-correct-wrapper)))
#+end_src

** TODO Line wrapping
Visual-line-mode is pretty useful for the average document, but it looks very ugly without "adaptive wrap" turned on. The only reason I don't turn it on in Text-mode directly is that it would then end up in Org-mode as well, and it conflicts with =org-indent-mode=.
#+begin_src emacs-lisp
  (use-package adaptive-wrap
    :hook
    (text-mode . visual-line-mode)
    (markdown-mode . adaptive-wrap-prefix-mode)
    (latex-mode . adaptive-wrap-prefix-mode))
#+end_src

* [50%] Programming
** TODO General
Eglot has been built into Emacs since v29. I've tried the alternatives Lsp-mode and Lsp-bridge, but so far Eglot is the solution that has been most "plug and play" and least buggy. It also works over TRAMP if you install LSP servers remotely.
#+begin_src emacs-lisp
  (use-package eglot
    :custom
    (eldoc-echo-area-prefer-doc-buffer t)
    (eldoc-echo-area-use-multiline-p nil)
    :hook
    (python-mode . +eglot-project-ensure)
    :bind
    ("<f2>" . eglot-rename))
#+end_src

By default, Eglot tends to open documentation in another window. I prefer to have the documentation pop up at point, without disturbing my existing window configuration. Enter =eldoc-box=. (Unfortunately, it doesn't appear to work in TUI frames?)
#+begin_src emacs-lisp
  (use-package eldoc-box
    :bind
    ("<f1>" . eldoc-box-help-at-point))
#+end_src

Format-all is a decent package for automatically reformatting code on save. Emacs equivalent to part of Vim's ALE features.
#+begin_src emacs-lisp
    ;; (use-package format-all
    ;;   :hook
    ;;   (python-mode . format-all-mode)
    ;;   :config
    ;;   (setq-default format-all-formatters
    ;;                 '(("Python" (isort) (ruff)))))
    ;;                 ;; '(("Python" (isort) (ruff) (black)))))
#+end_src

Github Copilot support for Emacs.
#+begin_src emacs-lisp
  ;; (use-package copilot
  ;;   :vc (:url "https://github.com/copilot-emacs/copilot.el" :rev "main")
  ;;   :custom
  ;;   (copilot-idle-delay 1)
  ;;   ;; :hook
  ;;   ;; (prog-mode . copilot-mode)
  ;;   :bind
  ;;   (:map copilot-mode-map
  ;;         ("M-RET" . copilot-accept-completion)
  ;;         ("M-n"   . copilot-next-completion)
  ;;         ("M-p"   . copilot-previous-completion)))
#+end_src

** TODO Python
First, let's load the built-in Python-mode.
#+begin_src emacs-lisp
  (use-package python
    :custom
    (python-indent-guess-indent-offset t)  
    (python-indent-guess-indent-offset-verbose nil))
#+end_src

Jupyter-mode replaces the "Inferior Python" feature (=C-c C-p=). Notably, Jupyter-mode can capture Matplotlib plots and display them in Emacs buffers, which provides a similar interface as Spyder and VSCode for data visualization in Python. With my setup, pressing =C-c C-c= once in a Python buffer starts up the Jupyter kernel, and pressing =C-c C-c= more times after that then evaluates the current line or region.
#+begin_src emacs-lisp :tangle no
    (use-package jupyter
      :config
      (defun jabirali/jupyter-python ()
        (interactive)
        (jupyter-run-repl "python3" "py" t)
        (message "Jupyter kernel started!"))
      :bind
      (:map python-mode-map
            ("C-c C-c" . jabirali/jupyter-python)))
#+end_src

Ruff is a pretty nice Python linter. Let's integrate it into Flymake for continuous feedback.
#+begin_src emacs-lisp
  (use-package flymake-ruff
    :hook
    (python-mode . flymake-mode)
    (python-mode . flymake-ruff-load))
#+end_src

** DONE Julia
Syntax highlighting for Julia files.
#+begin_src emacs-lisp
  (use-package julia-mode)
#+end_src

** DONE Matlab
Syntax highlighting for Matlab files.
#+begin_src emacs-lisp
  (use-package matlab)
#+end_src

* [0%] Refactor in progress
** TODO Functions
#+begin_src emacs-lisp
  (defun jabirali/science-definition-lookup ()
    "Look up a scientific definition using a ChatGPT wrapper."
    (interactive)
    (let* ((query (buffer-substring (region-beginning) (region-end)))
           (encoded-query (url-encode-url query))
           (search-url "https://chat.openai.com/g/g-Kihf3Sccx-science-definitions?q="))
      (browse-url (concat search-url encoded-query))))

  (bind-key "<f12>" #'jabirali/science-definition-lookup)
#+end_src

#+begin_src emacs-lisp
    (defun +org-find-file ()
      "Open one of my Org files (or create a new one)."
      (interactive)
      (let ((default-directory org-directory))
        (find-file (completing-read "Org: " (directory-files "." nil "\\.org$")))))
#+end_src

#+begin_src emacs-lisp
  (defun +eglot-project-ensure ()
    "Enable Eglot iff the current buffer belongs to a project."
    (if (project-current) (eglot-ensure)))
#+end_src

#+begin_src emacs-lisp
  (defun +theme-override (&rest _)
    "Override the current theme for a consistent and minimal look."
    (let ((bg0 (face-attribute 'default :background))
          (bg1 (face-attribute 'mode-line :background))
          (bg2 (face-attribute 'mode-line :background))
          (fg0 (face-attribute 'default :foreground))
          (fg1 (face-attribute 'mode-line :foreground))
          (fg2 (face-attribute 'mode-line-inactive :foreground)))
      (set-face-attribute 'tab-bar nil :foreground bg2 :background bg2 :box `(:line-width 6 :color ,bg2))
      (set-face-attribute 'tab-bar-tab nil :foreground fg2 :background bg2 :box `(:line-width 6 :color ,bg2) :weight 'bold)
      (set-face-attribute 'tab-bar-tab-inactive nil :foreground fg2 :background bg2 :box `(:line-width 6 :color ,bg2))
      (set-face-attribute 'mode-line nil :background bg1 :box `(:line-width 6 :color ,bg1))
      (set-face-attribute 'mode-line-inactive nil :background bg1 :box `(:line-width 6 :color ,bg1))
      (set-face-attribute 'fringe nil :foreground bg0 :background bg0)
      (set-face-attribute 'scroll-bar nil :foreground bg2 :background bg2)
      (set-face-attribute 'vertical-border nil :foreground bg1 :background bg1)
      (set-face-italic-p 'font-lock-comment-face nil)
      (set-face-italic-p 'font-lock-builtin-face nil)))

  (advice-add 'load-theme :after #'+theme-override)
#+end_src

#+begin_src emacs-lisp
  ;; (use-package spacious-padding
  ;;   :config
  ;;   (spacious-padding-mode 1))
#+end_src

#+begin_src emacs-lisp
  (defun +url-handler-zotero (link)
    "Open a zotero:// link in the Zotero desktop app."
    (start-process "zotero_open" nil "open" (concat "zotero:" link)))
#+end_src

** TODO Internal packages
#+begin_src emacs-lisp
  (use-package tab-bar
    :custom
    (tab-bar-close-button-show nil)
    (tab-bar-format '(tab-bar-format-tabs))
    (tab-bar-new-tab-choice "*scratch*")
    (tab-bar-separator "  ")
    (tab-bar-show t)
    (tab-bar-tab-hints t)
    :bind*
    ("C-c [" . tab-bar-history-back)
    ("C-c ]" . tab-bar-history-forward)
    :config
    ;; Rename new tabs interactively.
    ;; (defun jabirali/rename-tab (&rest _)
    ;;   (call-interactively #'tab-bar-rename-tab))
    ;; (add-hook 'tab-bar-tab-post-open-functions #'jabirali/rename-tab)

    ;; Enable the mode globally.
    (tab-bar-mode 1)
    (tab-bar-history-mode 1))
#+end_src

** TODO External packages
#+begin_src emacs-lisp
  (use-package persistent-scratch
    :after (org evil)
    :config
    (persistent-scratch-autosave-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package ace-window
    :config
    (set-face-attribute 'aw-leading-char-face nil :height 1)
    (defun +other-window-dwim ()
      "Select either the minibuffer or an arbitrary visible window."
      (interactive)
      (if (active-minibuffer-window)
          (select-window (active-minibuffer-window))
        (call-interactively #'ace-window)))
    :bind
    ("M-o" . +other-window-dwim))
#+end_src

#+begin_src emacs-lisp
  (use-package company
    :after eglot
    :bind (:map prog-mode-map ("<tab>" . company-indent-or-complete-common))
    :hook (eglot-managed-mode . company-mode))
#+end_src


#+begin_src emacs-lisp
  (use-package diredfl
    :after dired
    :config
    (diredfl-global-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-bar-width 0.1)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-buffer-modification-icon nil)
    (doom-modeline-env-enable-python nil)
    (doom-modeline-icon nil)
    (doom-modeline-modal nil)
    (doom-modeline-position-line-format nil)
    (doom-modeline-time nil)
    (doom-modeline-workspace-name nil)
    :config
    (doom-modeline-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package ef-themes
    :config
    (load-theme 'ef-melissa-light t))
#+end_src

#+begin_src emacs-lisp
  (use-package expand-region
    :bind
    ("C-c SPC" . er/expand-region))
#+end_src


#+begin_src emacs-lisp
  (use-package gnuplot)
#+end_src 

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook
    (prog-mode . hl-todo-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package iedit)
#+end_src

#+begin_src emacs-lisp
  (use-package magit
    :bind
    (:map magit-status-mode-map ("SPC" . nil))
    :custom
    (magit-diff-refine-hunk 'all)
    :config
    (setq magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    (add-to-list 'project-switch-commands '(magit-project-status "Magit") t)
    (keymap-set project-prefix-map "m" #'magit-project-status)) 
#+end_src

#+begin_src emacs-lisp
  (use-package prescient)
#+end_src

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode 1)
    (vertico-mouse-mode 1)) 
#+end_src

#+begin_src emacs-lisp
  (use-package vertico-directory
    :after vertico
    :bind (:map vertico-map
                ("RET"   . vertico-directory-enter)
                ("DEL"   . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)) 
#+end_src

#+begin_src emacs-lisp
  (use-package vertico-prescient
    :after (vertico prescient)
    :config
    (vertico-prescient-mode 1)) 
#+end_src

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode 1)) 
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package yasnippet
    :config
    (yas-global-mode 1)) 
#+end_src

** TODO Global keybindings
#+begin_src emacs-lisp
  (use-package general
    :after evil
    :config
    (general-evil-setup t)
    (general-override-mode 1)
    (general-create-definer gmap
      :keymaps 'override
      :states '(motion normal visual)
      :prefix "SPC")
    (general-create-definer lmap
      :keymaps 'override
      :states '(motion normal visual)
      :prefix ","))
#+end_src

#+begin_src emacs-lisp
  (mmap                                           ; Motion map
    "^" 'dired-jump) 
#+end_src

#+begin_src emacs-lisp
  (vmap                                           ; Visual map
    "ii" 'er/expand-region) 
#+end_src

#+begin_src emacs-lisp
  (gmap                                           ; Space menu
    "SPC" '(execute-extended-command :which-key "cmd")
    "1" '(tab-bar-select-tab :which-key "1")
    "2" '(tab-bar-select-tab :which-key "2")
    "3" '(tab-bar-select-tab :which-key "3")
    "4" '(tab-bar-select-tab :which-key "4")
    "5" '(tab-bar-select-tab :which-key "5")
    "6" '(tab-bar-select-tab :which-key "6")
    "7" '(tab-bar-select-tab :which-key "7")
    "8" '(tab-bar-select-tab :which-key "8")
    "9" '(tab-bar-select-tab :which-key "9")
    "b" '(switch-to-buffer :which-key "buffer")
    "d" '(dired-jump :which-key "dired")
    "f" '(find-file :which-key "file")
    "g" '(magit :which-key "git")
    "h" `(,help-map :which-key "help")
    "i" '(imenu :which-key "imenu")
    "j" '(bookmark-jump :which-key "jump")
    "k" '(kill-this-buffer :which-key "kill")
    "n" `(,narrow-map :which-key "narrow")
    "o" '(ace-window :which-key "other")
    "p" `(,project-prefix-map :which-key "project")
    "q" '(delete-window :which-key "quit window")
    "Q" '(tab-close :which-key "quit tab")
    "r" '(recentf :which-key "recent")
    "s" '(save-buffer :which-key "save")
    "t" '(tab-bar-new-tab :which-key "tab")
    "w" `(,evil-window-map :which-key "window")
    "y" '(clone-indirect-buffer-other-window :which-key "indirect")) 
#+end_src


#+begin_src emacs-lisp
  (lmap                                           ; Major modes
    "," (general-key "C-c C-c")
    "a" (general-key "C-c C-a")
    "b" (general-key "C-c C-b")
    "c" (general-key "C-c C-c")
    "d" (general-key "C-c C-d")
    "e" (general-key "C-c C-e")
    "f" (general-key "C-c C-f")
    "g" (general-key "C-c C-g")
    "h" (general-key "C-c C-h")
    "i" (general-key "C-c C-i")
    "j" (general-key "C-c C-j")
    "k" (general-key "C-c C-k")
    "l" (general-key "C-c C-l")
    "m" (general-key "C-c C-m")
    "n" (general-key "C-c C-n")
    "o" (general-key "C-c C-o")
    "p" (general-key "C-c C-p")
    "q" (general-key "C-c C-q")
    "r" (general-key "C-c C-r")
    "s" (general-key "C-c C-s")
    "t" (general-key "C-c C-t")
    "u" (general-key "C-c C-u")
    "v" (general-key "C-c C-v")
    "w" (general-key "C-c C-w")
    "x" (general-key "C-c C-x")
    "y" (general-key "C-c C-y")
    "z" (general-key "C-c C-z")) 
#+end_src

#+begin_src emacs-lisp
  (lmap                                           ; Minor modes
    "!"  (general-key "C-c !" )
    "\"" (general-key "C-c \"")
    "#"  (general-key "C-c #" )
    "$"  (general-key "C-c $" )
    "%"  (general-key "C-c %" )
    "&"  (general-key "C-c &" )
    "'"  (general-key "C-c '" )
    "("  (general-key "C-c (" )
    ")"  (general-key "C-c )" )
    "*"  (general-key "C-c *" )
    "+"  (general-key "C-c +" )
    "-"  (general-key "C-c -" )
    "."  (general-key "C-c ." )
    "/"  (general-key "C-c /" )
    ":"  (general-key "C-c :" )
    ";"  (general-key "C-c ;" )
    "<"  (general-key "C-c <" )
    "="  (general-key "C-c =" )
    ">"  (general-key "C-c >" )
    "?"  (general-key "C-c ?" )
    "@"  (general-key "C-c @" )
    "["  (general-key "C-c [" )
    "\\" (general-key "C-c \\")
    "]"  (general-key "C-c ]" )
    "^"  (general-key "C-c ^" )
    "_"  (general-key "C-c _" )
    "`"  (general-key "C-c `" )
    "{"  (general-key "C-c {" )
    "|"  (general-key "C-c |" )
    "}"  (general-key "C-c }" )
    "~"  (general-key "C-c ~" ))
#+end_src

* TODO Custom modes
** Monospace-mode
One of the reasons I've kept going back to Emacs in the terminal for a while, is that I really like my editor buffers to respect the monospace grid. Somehow, I find it easier to edit documents using the keyboard only if the document uses a single face (no proportional fonts), size (no huge headings), and single base line (i.e. no real superscripts/subscripts). Many themes and packages tend to make these things a bit too fancy for my liking, and playing whack-a-mole with config options to reverse it is no fun. I therefore want an automated way to use a single mono font everywhere in the Emacs GUI, while retaining the nice things a GUI offers (e.g. =pdf-view=, =xenops-mode=, =comint-mime=).

Probably just a habit from nearly 2 decades as a Vim user... I like proportional fonts and real superscripts when /reading/ documents, just not when /writing/ or /editing/ them.

Also disables italics by default, even though they're monospace. I somehow find monospace italics very hard to read compared to proportional italics.

Here is some code generated by ChatGPT 4. I'll have to clean it up and can then consider wrapping it as a package later. If so, consider making each property customizable (disable variable-pitch, italics, variable height).
#+begin_src emacs-lisp
  (defun my-customize-faces ()
    "Customize all faces to be non-italic, use the default font family, and have the same font size."
    (interactive)
    (let ((default-height (face-attribute 'default :height)))
      (mapcar
       (lambda (face)
         (when (facep face)
           (set-face-attribute face nil :slant 'normal)
           (set-face-attribute face nil :family 'unspecified)
           (set-face-attribute face nil :height default-height)))
       (face-list))
      (set-face-attribute 'variable-pitch nil
                          :inherit 'default
                          :family 'unspecified
                          :slant 'normal
                          :height default-height)))

  (defun my-reapply-custom-faces (&rest _)
    "Reapply custom faces after loading a theme."
    (when my-custom-faces-mode
      (my-customize-faces)))

  (define-minor-mode my-custom-faces-mode
    "A minor mode to apply custom face settings."
    :lighter " MyFaces"
    :global t
    (if my-custom-faces-mode
        (progn
          (my-customize-faces)
          (advice-add 'load-theme :after #'my-reapply-custom-faces))
      (advice-remove 'load-theme #'my-reapply-custom-faces)
      (message "My custom faces mode disabled")))

  ;; Enable the minor mode by default
  (my-custom-faces-mode 1)
#+end_src

* DONE Profiling
It is a continuous project to keep Emacs fast and lean. Monitoring the start-up time is a good way to start, but I might consider adopting things like the [[https://github.com/jschaf/esup][Emacs Start Up Profiler]] if things get too much out of hand.
#+begin_src emacs-lisp
  (defun +init-time ()
    "Print the Emacs start-up time in milliseconds."
    (interactive)
    (message (emacs-init-time "Emacs init time: %.2f s")))
  (add-hook 'emacs-startup-hook #'+init-time)
#+end_src

* DONE Tangle
This little snippet of code ensures that every time I save my =config.org= notebook from within Emacs, it automatically exports the embedded code blocks to the appropriate files: =init.el=, =early-init.el=, etc.
#+begin_src
  Local Variables:
    eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
  End:
#+end_src
  
