#+TITLE: Emacs configuration
#+AUTHOR: Jabir Ali Ouassou
#+PROPERTY: header-args:emacs-lisp :tangle "init.el"

* Tasks
This section is for planned maintenance tasks for my Emacs config.

** TODO Make a reproducible config
- Store =package.el= packages (including =el= and =elc= files, excluding =eln=, =so=, =dylib= files) in my Git dotfiles repo. That way, the exact same package versions are used remotely as well.
- Move to =straight.el= that supports lockfiles (via its =freeze= / =thaw= mechanism).
- Move to =elpaca= that supports ultrafast parallelized bootstrap remotely.
- Remove the =ensure t= flags if I do add all my packages to Git.

** TODO Improve the performance
I've already toggled on =defer= as default for =use-package=. Perhaps I can still do better, by e.g. making things toggle on =after-init-hook= that don't need usage immediately? Or reducing some =use-package= blocks to simple =setopt= if I don't actually need to use the package at boot? Etc?
** TODO Consider better modifiers
On Apple keyboards, a lower-left {Fn, Ctrl, Opt, Cmd} mapped to {Hyper, Super, Meta, Ctrl} makes sense.

** TODO Make some =general.el= code into a module
Especially the code that just remaps =C-c C-...= into =, ...= is well-suited for a module.

** TODO Look into =speed-rect=
Makes rectangle selections more useful. See [[https://github.com/jdtsmith/speedrect]].

* Why Emacs?
Sometimes I ask myself the same question... I've been a Vim user since the mid-2000s, and regularly consider switching back since I haven't been able to completely let go of Vim. I've also been using other editors like VSCode on and off since ~2020, since it handles some things like data visualization and notebooks in a better way than either Emacs or Vim does. Moreover, maintaining a usable Emacs config takes some time and energy, since I don't find the default settings of either vanilla Emacs or Doom Emacs to be that usable. So why bother?

Some of the answers that I keep returning to:
- Org-mode :: I've tried plenty of note-taking apps over the years: Logseq, Obsidian, Bear, iA Writer, Apple Notes, Zim, Wiki.vim, etc. I still have yet to find anything as usable as Emacs Org-mode (although Logseq came close, and I happily used that for a while).
- CDLaTeX :: Most snippet solutions are not as ergonomic as this. The VimTeX one comes close, but doesn't work in e.g. MarkDown last I checked, which is one main place I do want it to work.
- TRAMP :: I don't use it that much, but remote workflows is a definite strength of Emacs. If I just quickly need to e.g. copy-paste some code between remote hosts, it's way easier to go via Emacs.

* [100%] Installation
** DONE Mac port
The "Mac port" integrates well with MacOS, including full Retina support and better trackpad support. But it doesn't work as well as the [[NS port]] in the terminal and updates are usually slower.

To build it from source (to get native compilation and a nicer icon):
#+begin_src sh
  brew tap railwaycat/emacsmacport
  brew install emacs-mac \
      --with-native-compilation --with-emacs-big-sur-icon --with-natural-title-bar
#+end_src

To install the pre-built version (slower but less chance of problems):
#+begin_src sh
  brew tap railwaycat/emacsmacport
  brew install --cask emacs-mac
#+end_src

After installation, we might want to get [[https://github.com/zachcurry/emacs-anywhere][Emacs Anywhere]] running. I have no idea why the second line is needed, but after some trial and error that was the only way to get the right accessibility permissions. Remember to also bind Emacs Anywhere to a keybinding under System Preferences \rightarrow Keyboard Shortcuts.
#+begin_src sh
  curl -fsSL https://raw.github.com/zachcurry/emacs-anywhere/master/install | bash
  osascript -e 'tell application "System Events"' -e 'keystroke "echo ..."' -e end tell
#+end_src

** DONE NS port
The "NextStep port" is the official GNU Emacs release. This means that it's updated more often and more similar across OS versions. I prefer the patched "Emacs Plus" version, which can be fetched via HomeBrew:
#+begin_src sh
  brew tap d12frosted/emacs-plus
  brew install emacs-plus@30 --with-native-comp --with-nobu417-big-sur-icon 
#+end_src

On Intel MacBooks that can't (or are too slow for) the latest version of MacOS, the best option is to fetch the prebuilt version from [[https://emacsformacosx.com/][EmacsForMacOSX.com]]. That way, you don't need to compile every single dependency.

** DONE Linux
On an up-to-date Ubuntu system, the newest major version is usually in the main repos:
#+begin_src sh
  sudo apt install emacs
#+end_src

On outdated servers, it might be better to fetch a recent build from =conda-forge=:
#+begin_src sh
  conda install -n base -c conda-forge emacs
#+end_src

* [22%] Basic settings
** DONE Packages
Before we install anything else, let's enable the community repositories and turn on native compilation.
#+begin_src emacs-lisp
  (use-package use-package
    :custom
    (package-native-compile t)
    (native-comp-async-report-warnings-errors nil)
    (use-package-compute-statistics t)
    :config
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
#+end_src

Note that we don't turn on the common =use-package-always-demand= and =use-package-always-ensure= settings anymore. The former slows down the start-up quite significantly, and the latter is less reproducible and reversible than handling package installations manually and then syncing the =elpa= directory via Git.

In the future, it might be better to migrate to e.g. =straight.el= or =elpaca= for a more seamless sync of package versions between different hosts. For now, I prefer to use the built-in packages when adequate.

** DONE No littering
First of all, let's prevent Emacs from littering my =init.el= file with autogenerated stuff, including the package installation list. Note that this must be set early in the init process to take effect.
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (ignore-errors (load custom-file))
#+end_src

The =no-littering= package does a good job of keeping everything else out of the way.
#+begin_src emacs-lisp
  (use-package no-littering
    :config
    (no-littering-theme-backups))
#+end_src

** TODO Sane defaults
Here's a hodgepodge of built-in Emacs settings. Many of them just try to get rid of anachronisms.
#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (auto-save-default nil)
    (default-input-method 'TeX)
    (default-transient-input-method 'TeX)
    (inhibit-startup-echo-area-message "jabirali")
    (dired-listing-switches "-hlLgG --group-directories-first --time-style=long-iso")
    (frame-title-format "GNU Emacs")
    (fringes-outside-margins t)
    (inhibit-startup-message t)
    (initial-scratch-message "")
    (line-spacing 0.15)
    (make-backup-files nil)
    (message-truncate-lines t)
    (ring-bell-function 'ignore)
    (sentence-end-double-space nil)
    (tab-width 4)
    (use-short-answers t)
    (xterm-set-window-title t)
    :custom-face
    (default ((t (:family "JetBrains Mono NL" :height 140))))
    :bind
    ("C-\\" . activate-transient-input-method)
    ("<f5>" . sort-lines)
    :config
    ;; Don't indicate long or wrapped lines.
    (set-display-table-slot standard-display-table 'truncation ? )
    (set-display-table-slot standard-display-table 'wrap ? )
    ;; Turn on some useful default modes.
    (global-auto-revert-mode 1)
    (recentf-mode 1)
    (savehist-mode 1)
    ;; Disable the annoying default modes.
    (blink-cursor-mode -1)
    (menu-bar-mode -1)
    (when (display-graphic-p)
      (fringe-mode 1)
      (tooltip-mode -1)
      (tool-bar-mode -1)
      (scroll-bar-mode -1)))
#+end_src

Let's also increase the garbage collection threshold a bit. This makes Emacs stutter a bit less and speeds up the start-up process.
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq gc-cons-threshold (* 128 1024 1024)
        read-process-output-max (* 1024 1024))
#+end_src
** TODO Graphical interface
Let's add some extra breathing room around the buffer text.
#+begin_src emacs-lisp :tangle "early-init.el"
  (setq-default left-margin-width 2
                right-margin-width 2)
#+end_src

Let's remove the breathing room around the tab bar and mode line, however. Usually, it's too small too look nice anyway, and it makes the tab bar in particular look a bit "fake" somehow.
#+begin_src emacs-lisp :tangle "early-init.el"
  (add-to-list 'default-frame-alist '(internal-border-width . 0))
#+end_src

When using a tiling window manager, it's annoying when an app decides that it doesn't want to confirm to your "grid". Fix it.
#+begin_src emacs-liso
  (setopt frame-resize-pixelwise t)
#+end_src

I'm tired of manually disabling italics everywhere in Emacs (comments, keywords, etc.) each time I'm trying out new themes. Let's just disable italics globally instead, similarly to the good old monospace terminals.
#+begin_src emacs-lisp
  (set-face-italic-p 'italic nil)
#+end_src

** TODO Terminal interface
The "Kitty Keyboard Protocol" lets you use GUI keybindings in the TUI version of Emacs. Requires the Kitty terminal emulator though.
#+begin_src emacs-lisp
  ;; (use-package kkp
  ;;  :custom
  ;;  (kkp-super-modifier 'meta)
  ;;  :config
  ;;  (global-kkp-mode +1))
#+end_src

These settings enable terminal mouse support and scrolling.
#+begin_src emacs-lisp
  ;; (setopt mouse-wheel-follow-mouse t)
  ;; (setopt mouse-wheel-progressive-speed nil)
  ;; (mouse-wheel-mode 1)
  ;; (xterm-mouse-mode 1)
#+end_src  

This package lets Emacs interact with the system clipboard also when running in a terminal. Despite the name it works on both Linux and MacOS. However, note that so far, this doesn't appear to work with the new =yank-media= command from Emacs 29?
#+begin_src emacs-lisp
  (use-package xclip
    :config
    (xclip-mode 1))
#+end_src

** TODO Mouse and trackpad
It can be quite distracting when the mouse randomly highlights every little clickable thing. Let's just disable that.
#+begin_src emacs-lisp
  (setopt mouse-highlight nil)
#+end_src
  
** TODO Keyboard settings
As an Evil user, I don't really need the Super key available. I do however need an easily accessible Meta key (e.g. for =M-RET= in Org-mode), and I do need an Option key (to type in Norwegian).
#+begin_src emacs-lisp
  (setopt mac-command-modifier 'meta)
  (setopt mac-option-modifier 'option)
#+end_src

I regularly switch between ISO and ANSI style keyboards, which can be quite annoying since the backtick and tilde symbols keep moving around (and I use both of them a lot). Let's fix that.
#+begin_src emacs-lisp
  (define-key key-translation-map (kbd "§") (kbd "`"))
  (define-key key-translation-map (kbd "±") (kbd "~"))
#+end_src

** TODO Emacs server
Run Emacs as a server. I chose to run it over TCP, because this lets me SSH forward the server to remote hosts. When I'm in a remote shell, I can then easily phone home via =emacsclient= to spawn new Tramp connections.
#+begin_src emacs-lisp
  (use-package server
    ;; :custom
    ;;(server-use-tcp t)
    ;;(server-port 1337)
    :config
    (server-mode 1))
#+end_src

* [75%] Keybindings
** DONE Evil-mode
First of all, let's enable the "Evil mode". As someone with a Vim background, this is more ergonomic for both my brain and my hands. It's worth noting that =evil-respect-visual-line-mode= is quite important here, since it makes the document writing (TeX, Org, MarkDown) much easier.
#+begin_src emacs-lisp
  (use-package evil
    :custom
    (evil-respect-visual-line-mode t)
    (evil-undo-system 'undo-redo)
    (evil-want-C-i-jump nil)
    (evil-want-C-u-scroll t)
    (evil-want-integration t)
    (evil-want-keybinding nil)
    :config
    (evil-mode 1)
    (define-key evil-motion-state-map (kbd "SPC") nil)
    (define-key evil-motion-state-map (kbd "RET") nil)
    (define-key evil-motion-state-map (kbd "TAB") nil))
#+end_src
** DONE Evil collection
Evil Collection is what is sounds like: It makes Evil work in nearly every corner of Emacs.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src
Note: I might later wish to look into =evil-collection-key-blacklist= to protect keybindings that I don't want Evil to override.

Org-mode is not sufficiently well covered by Evil Collection, and requires an additional plugin to work as expected.
#+begin_src emacs-lisp
  (use-package evil-org
    :after (evil org)
    :hook
    (org-mode . evil-org-mode))
#+end_src

LaTeX works fine without Evil integration, but =evil-tex= provides some sorely missed text objects from VimTeX. This lets me e.g. press =dsc= to "delete surrounding command", which I do all the time to remove special formatting from pieces of text.
#+begin_src emacs-lisp
  (use-package evil-tex
    :hook
    (LaTeX-mode . evil-tex-mode))
#+end_src
** DONE Evil extensions
"Evil Surround" provides surround text objects. This lets me e.g. type =cs])= to change =[...]= to =(...)=.
#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode 1))
#+end_src

** TODO Global keybindings
#+begin_src emacs-lisp
  (bind-key* "M-j" 'avy-goto-word-1)
#+end_src

* [40%] Writing
** TODO Org-mode notes
Org-mode is my favorite task and knowledge management system.  It's no understatement that Org-mode is the main reason I'm using Emacs at all (otherwise I'd probably be using Vim).
#+begin_src emacs-lisp
  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :custom
    (org-adapt-indentation nil)
    (org-agenda-files (list org-directory))
    (org-agenda-window-setup 'only-window)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-span 'day)
    (org-agenda-start-on-weekday nil)
    (org-archive-location "::* Archive")
    (org-babel-results-keyword "results")
    (org-confirm-babel-evaluate nil)
    (org-ctrl-k-protect-subtree t)
    (org-directory "~/iCloud/Notes")
    (org-fontify-quote-and-verse-blocks t)
    (org-highlight-latex-and-related '(native latex script entities))
    (org-image-actual-width '(400))
    (org-pretty-entities t)
    (org-use-sub-superscripts '{})
    (org-pretty-entities-include-sub-superscripts nil)
    (org-return-follows-link t)
    (org-startup-folded 'fold)
    (org-startup-indented t)
    (org-tags-column -65)
    (org-todo-keywords
     '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
       (sequence "WAIT(w)" "HOLD(h)" "READ(r)" "IDEA(*)" "|" "NOTE(-)" "STOP(s)")))
    :config
    (setopt org-latex-src-block-backend 'engraved)
    (setopt org-latex-engraved-theme 'ef-melissa-light)
    (setopt org-latex-packages-alist '(("" "microtype" t)))
    (setopt org-latex-hyperref-template "
  \\hypersetup{\n pdfauthor={%a},\n pdftitle={%t},\n pdfkeywords={%k},
   pdfsubject={%d},\n pdfcreator={%c},\n pdflang={%L},\n colorlinks=true}\n")
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (julia . t)
       (python . t)))
    (org-link-set-parameters "zotero" :follow #'+url-handler-zotero))
#+end_src

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-completion-everywhere t)
    (org-roam-directory (expand-file-name "roam" org-directory))
    (org-roam-dailies-directory "../daily")
    :bind
    ("C-c n l" . org-roam-buffer-toggle)
    ("C-c n f" . org-roam-node-find)
    ("C-c n g" . org-roam-graph)
    ("C-c n i" . org-roam-node-insert)
    ("C-c n c" . org-roam-capture)
    ("C-c n j" . org-roam-dailies-capture-today)
    ("C-c n d" . org-roam-dailies-goto-date)
    ("C-c n n" . org-roam-node-find)
  :config
  (org-roam-db-autosync-mode))
#+end_src

The following code provides the popular "Zettelkasten IDs" for Org-mode files instead of the default UUIDs. This kind of date-based formats is more human-readable, and contains non-random metadata: creation date.
#+begin_src emacs-lisp
  (setopt org-id-method 'ts)
  (setopt org-id-ts-format "%Y%m%d%H%M%S")
  ;; (setopt org-roam-capture-templates
  ;;         '(("d" "default" plain "%?"
  ;;                :target (file+head "%<%Y%m%d%H%M%S>.org" "#+title: ${title}")
  ;;                :unnarrowed t)))
#+end_src

#+begin_src emacs-lisp
  (defun org-attach-id-to-path (id)
    "Store attachments as 'data/org-id/file' in 'org-directory'."
    (let ((attach-dir (expand-file-name "data" org-directory)))
      (unless (file-directory-p attach-dir)
        (make-directory attach-dir t))
      (expand-file-name id attach-dir)))

  (setopt org-attach-id-to-path-function-list '(org-attach-id-to-path))
#+end_src

I used to use =org-download= to enable copy-paste and drag-and-drop of image attachments into Org files. That is no longer needed, thanks to the =yank-media= command introduced in recent Emacs versions.

Let's support Pandoc export. This is especially useful to generate DOCX files with TeX equations.
#+begin_src emacs-lisp
  (use-package ox-pandoc
    :if (executable-find "pandoc"))
#+end_src

** TODO MarkDown notes
MarkDown is the lingua franca of mark-up languages, and the Emacs mode is great with the right settings.
#+begin_src emacs-lisp
  (use-package markdown-mode
    :config
    (setopt markdown-fontify-code-blocks-natively t)
    (setopt markdown-enable-wiki-links t)
    (setopt markdown-enable-math t))
    ;; :hook
    ;;(markdown-mode . cdlatex-mode)) 
#+end_src

** TODO TeX documents
AUCTeX is the de facto default TeX mode for Emacs. Let's set it up to sync with Skim on MacOS.
#+begin_src emacs-lisp
  (use-package tex
    :custom
    (font-latex-fontify-script nil)
    (TeX-auto-save t)
    (TeX-source-correlate-method 'synctex)
    (TeX-source-correlate-mode t)
    (TeX-source-correlate-start-server t)
    (TeX-view-program-list '(("Skim" "/Applications/Skim.app/Contents/SharedSupport/displayline -b -g %n %o %b")))
    (TeX-view-program-selection '((output-pdf "Skim")))) 
#+end_src

CDLaTeX is one of the main reasons I love writing LaTeX in Emacs. It's very ergonomic and intuitive after you get used to it, and it works very well in both Org-mode and TeX-mode.
#+begin_src emacs-lisp
  (use-package cdlatex
    :hook
    ((TeX-mode . turn-on-cdlatex)
     (org-mode . turn-on-org-cdlatex)))
#+end_src

** DONE Spell checking
Ispell is a spell checker that is built into Emacs. It supports many different backends, but I use Hunspell:

1. It supports multi-language dictionary combinations, so I can spellcheck my notes that tend to mix English and Norwegian;
2. It is supposedly more accurate for non-English languages, although I haven't really put this to the test;
3. It is the de facto standard backend in the open-source world, being used by e.g. LibreOffice, Firefox, and Chrome by default. 
  
Note that on MacOS, you need to [[https://github.com/wooorm/dictionaries][download]] the appropriate dictionaries and extract them into =~/Library/Spelling=. The config below assumes the files are named using locale codes like =en_US=.
#+begin_src emacs-lisp
  (use-package ispell
    :if (executable-find "hunspell")
    :config
    (setopt ispell-program-name "hunspell")
    (setopt ispell-dictionary "en_US,nb_NO")
    (setopt ispell-personal-dictionary (concat user-emacs-directory "ispell"))
    (ispell-set-spellchecker-params)
    (ispell-hunspell-add-multi-dic "en_US,nb_NO"))
#+end_src

Flyspell is a built-in Emacs package that provides incremental as-you-write spell checking. Let's turn it on.
#+begin_src emacs-lisp
  (use-package flyspell
    :after ispell
    :hook
    ((text-mode . flyspell-mode)
     (prog-mode . flyspell-prog-mode)))
#+end_src

The default Flyspell interface and keybindings are not comfortable, especially if you frequently add words to your personal dictionary. I'd rather have an interface based on =completing-read= (e.g. =vertico=), and the package =flyspell-correct= solves this.
#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :bind
    (:map flyspell-mode-map
          ("C-;" . flyspell-correct-wrapper)))
#+end_src

** DONE Line wrapping
I don't like line wrapping when editing code, but do want lines to wrap at word boundaries when editing documents. This does the job:
#+begin_src emacs-lisp
  (setopt truncate-lines t)
  (use-package visual-line-mode
    :hook
    (text-mode . visual-line-mode)
    (org-roam-mode . visual-line-mode))
#+end_src

However, wrapped lines look ugly without =adaptive-wrap-prefix-mode=. This is a mode that basically indents wrapped lines, similarly to the =breakindentopt= settings in Vim. It conflicts with =org-indent-mode=, so I have to manually turn it on for TeX and MarkDown documents.
#+begin_src emacs-lisp
  (use-package adaptive-wrap
    :hook
    (markdown-mode . adaptive-wrap-prefix-mode)
    (LaTeX-mode . adaptive-wrap-prefix-mode)
    (org-roam-mode . adaptive-wrap-prefix-mode))
#+end_src

* [75%] Programming
** TODO General
Eglot has been built into Emacs since v29. I've tried the alternatives Lsp-mode and Lsp-bridge, but so far Eglot is the solution that has been most "plug and play" and least buggy. It also works over TRAMP if you install LSP servers remotely.
#+begin_src emacs-lisp
  (use-package eglot
    :custom
    (eldoc-echo-area-prefer-doc-buffer t)
    (eldoc-echo-area-use-multiline-p nil)
    :hook
    (python-mode . +eglot-project-ensure)
    :bind
    ("<f2>" . eglot-rename))
#+end_src

By default, Eglot tends to open documentation in another window. I prefer to have the documentation pop up at point, without disturbing my existing window configuration. Enter =eldoc-box=. (Unfortunately, it doesn't appear to work in TUI frames?)
#+begin_src emacs-lisp
  (use-package eldoc-box
    :bind
    ("<f1>" . eldoc-box-help-at-point))
#+end_src

Format-all is a decent package for automatically reformatting code on save. Emacs equivalent to part of Vim's ALE features.
#+begin_src emacs-lisp
    ;; (use-package format-all
    ;;   :hook
    ;;   (python-mode . format-all-mode)
    ;;   :config
    ;;   (setq-default format-all-formatters
    ;;                 '(("Python" (isort) (ruff)))))
    ;;                 ;; '(("Python" (isort) (ruff) (black)))))
#+end_src

Github Copilot support for Emacs.
#+begin_src emacs-lisp
  ;; (use-package copilot
  ;;   :vc (:url "https://github.com/copilot-emacs/copilot.el" :rev "main")
  ;;   :custom
  ;;   (copilot-idle-delay 1)
  ;;   ;; :hook
  ;;   ;; (prog-mode . copilot-mode)
  ;;   :bind
  ;;   (:map copilot-mode-map
  ;;         ("M-RET" . copilot-accept-completion)
  ;;         ("M-n"   . copilot-next-completion)
  ;;         ("M-p"   . copilot-previous-completion)))
#+end_src

** DONE Python
First, let's load the built-in Python-mode. The defaults mostly work fine, but there are two main things I want to fix:
1. I want =C-c C-p= to use IPython instead of Python as the "Inferior Python" process;
2. I want Emacs to stop complaining that it has to guess how Python files are indented.
#+begin_src emacs-lisp
  (use-package python
    :config
    (setopt python-indent-guess-indent-offset t)  
    (setopt python-indent-guess-indent-offset-verbose nil)
    (when (executable-find "ipython3")
      (setopt python-shell-interpreter "ipython3")
      (setopt python-shell-interpreter-args "--simple-prompt --classic")))
#+end_src

The package Comint-mime lets us show Matplotlib plots directly in Inferior Python buffers. This lets us replicate the "Interactive Python" workflow in e.g. VSCode, where one writes code in one split and sees the visual output in another split.
#+begin_src emacs-lisp
  (use-package comint-mime
    :custom
    (comint-mime-prefer-svg t)
    :hook
    (inferior-python-mode . comint-mime-setup))
#+end_src

This is the final piece of the "Interactive Python" workflow: Implementing support for "code cells", where parts of a script delimited by =# %%= markers can be navigated between and individually sent to the REPL.
#+begin_src emacs-lisp
  (use-package code-cells
    :after python
    :hook
    (python-mode . code-cells-mode-maybe)
    :bind
    (:map code-cells-mode-map
      ("M-p" . code-cells-backward-cell)
      ("M-n" . code-cells-forward-cell)
      ("M-RET" . code-cells-eval)))
#+end_src

Ruff is a fast and good Python linter. Integrate it into Flymake for continuous feedback if it's installed.
#+begin_src emacs-lisp
  (use-package flymake-ruff
    :if (executable-find "ruff")
    :hook
    (python-mode . flymake-mode)
    (python-mode . flymake-ruff-load))
#+end_src

** DONE Julia
Syntax highlighting for Julia files.
#+begin_src emacs-lisp
  (use-package julia-mode
    :mode ("\\.jl\\'" . julia-mode))
#+end_src

** DONE Matlab
Syntax highlighting for Matlab files.
#+begin_src emacs-lisp
  (use-package matlab)
#+end_src

* [100%] Configuration
** DONE YAML
It's weird that Emacs doesn't include a basic =yaml-mode= by default, given how widespread it has been as a config format for the past two decades. However, this one seems to work fine.
#+begin_src emacs-lisp
 (use-package yaml-mode) 
#+end_src

* [0%] Refactor in progress
** TODO Functions
#+begin_src emacs-lisp
  (defun jabirali/science-definition-lookup ()
    "Look up a scientific definition using a ChatGPT wrapper."
    (interactive)
    (let* ((query (buffer-substring (region-beginning) (region-end)))
           (encoded-query (url-encode-url query))
           (search-url "https://chat.openai.com/g/g-Kihf3Sccx-science-definitions?q="))
      (browse-url (concat search-url encoded-query))))

  (bind-key "<f12>" #'jabirali/science-definition-lookup)
#+end_src

#+begin_src emacs-lisp
    (defun +org-find-file ()
      "Open one of my Org files (or create a new one)."
      (interactive)
      (let ((default-directory org-directory))
        (find-file (completing-read "Org: " (directory-files "." nil "\\.org$")))))
#+end_src

#+begin_src emacs-lisp
  (defun +eglot-project-ensure ()
    "Enable Eglot iff the current buffer belongs to a project."
    (if (project-current) (eglot-ensure)))
#+end_src

#+begin_src emacs-lisp
  (defun +theme-override (&rest _)
    "Override the current theme for a consistent and minimal look."
    (let ((bg0 (face-attribute 'default :background))
          (bg1 (face-attribute 'mode-line :background))
          (bg2 (face-attribute 'mode-line :background))
          (fg0 (face-attribute 'default :foreground))
          (fg1 (face-attribute 'mode-line :foreground))
          (fg2 (face-attribute 'mode-line-inactive :foreground)))
      (set-face-attribute 'tab-bar nil :foreground bg2 :background bg2 :box `(:line-width 6 :color ,bg2))
      (set-face-attribute 'tab-bar-tab nil :foreground fg2 :background bg2 :box `(:line-width 6 :color ,bg2) :weight 'bold)
      (set-face-attribute 'tab-bar-tab-inactive nil :foreground fg2 :background bg2 :box `(:line-width 6 :color ,bg2))
      (set-face-attribute 'mode-line nil :background bg1 :box `(:line-width 6 :color ,bg1))
      (set-face-attribute 'mode-line-inactive nil :background bg1 :box `(:line-width 6 :color ,bg1))
      (set-face-attribute 'fringe nil :foreground bg0 :background bg0)
      (set-face-attribute 'scroll-bar nil :foreground bg2 :background bg2)
      (set-face-attribute 'vertical-border nil :foreground bg1 :background bg1)
      (set-face-italic-p 'font-lock-comment-face nil)
      (set-face-italic-p 'font-lock-builtin-face nil)))

  (advice-add 'load-theme :after #'+theme-override)
#+end_src

#+begin_src emacs-lisp
  ;; (use-package spacious-padding
  ;;   :config
  ;;   (spacious-padding-mode 1))
#+end_src

#+begin_src emacs-lisp
  (defun +url-handler-zotero (link)
    "Open a zotero:// link in the Zotero desktop app."
    (start-process "zotero_open" nil "open" (concat "zotero:" link)))
#+end_src

** TODO Internal packages
#+begin_src emacs-lisp
  (use-package tab-bar
    :custom
    (tab-bar-close-button-show nil)
    (tab-bar-format '(tab-bar-format-tabs))
    (tab-bar-new-tab-choice "*scratch*")
    (tab-bar-separator "  ")
    (tab-bar-show t)
    (tab-bar-tab-hints t)
    :bind*
    ("C-c [" . tab-bar-history-back)
    ("C-c ]" . tab-bar-history-forward)
    :config
    ;; Rename new tabs interactively.
    ;; (defun jabirali/rename-tab (&rest _)
    ;;   (call-interactively #'tab-bar-rename-tab))
    ;; (add-hook 'tab-bar-tab-post-open-functions #'jabirali/rename-tab)

    ;; Enable the mode globally.
    (tab-bar-mode 1)
    (tab-bar-history-mode 1))
#+end_src

** TODO External packages
I like this, but =use-package-report= flags it as the slowest part of my config. So time to disable it in the name of speed.
#+begin_src emacs-lisp :tangle no
  (use-package persistent-scratch
    :after (org evil)
    :config
    (persistent-scratch-autosave-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package ace-window
    :config
    (set-face-attribute 'aw-leading-char-face nil :height 1)
    (defun +other-window-dwim ()
      "Select either the minibuffer or an arbitrary visible window."
      (interactive)
      (if (active-minibuffer-window)
          (select-window (active-minibuffer-window))
        (call-interactively #'ace-window)))
    :bind
    ("M-o" . +other-window-dwim))
#+end_src

#+begin_src emacs-lisp
  (use-package company
    :bind*
    ("M-i" . company-complete)
    ;(:map prog-mode-map ("<tab>" . company-indent-or-complete-common))
    :custom
    (completion-ignore-case t)
    :config
    (add-to-list 'company-backends 'company-capf)
    (global-company-mode 1))
#+end_src


#+begin_src emacs-lisp
  (use-package diredfl
    :after dired
    :config
    (diredfl-global-mode 1))
#+end_src

#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-bar-width 0.1)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-buffer-modification-icon nil)
    (doom-modeline-env-enable-python nil)
    (doom-modeline-icon nil)
    (doom-modeline-modal nil)
    (doom-modeline-position-line-format nil)
    (doom-modeline-time nil)
    (doom-modeline-workspace-name nil)
    :config
    (doom-modeline-mode 1))
#+end_src

#+begin_src emacs-lisp
  ;; (use-package ef-themes
  ;;   :config
  ;;   (load-theme 'ef-melissa-light t))
#+end_src

#+begin_src emacs-lisp
  ;; (use-package ef-themes
  ;;   :config
  ;;   (load-theme 'ef-melissa-light t))
#+end_src

#+begin_src emacs-lisp
  (use-package expand-region
    :bind
    ("C-c SPC" . er/expand-region))
#+end_src


#+begin_src emacs-lisp
  (use-package gnuplot)
#+end_src 

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook
    (prog-mode . hl-todo-mode))
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package iedit)
#+end_src

#+begin_src emacs-lisp
  (use-package magit
    :custom
    (magit-diff-refine-hunk 'all)
    (magit-display-buffer-function #'magit-display-buffer-fullframe-status-v1)
    :bind
    ("C-x g" . magit-status)
    (:map magit-status-mode-map ("SPC" . nil)))
#+end_src

#+begin_src emacs-lisp
  (use-package prescient)
#+end_src

#+begin_src emacs-lisp
  (use-package vertico
    :config
    (vertico-mode 1)
    (vertico-mouse-mode 1)) 
#+end_src

#+begin_src emacs-lisp
  (use-package vertico-directory
    :after vertico
    :bind (:map vertico-map
                ("RET"   . vertico-directory-enter)
                ("DEL"   . vertico-directory-delete-char)
                ("M-DEL" . vertico-directory-delete-word))
    :hook (rfn-eshadow-update-overlay . vertico-directory-tidy)) 
#+end_src

#+begin_src emacs-lisp
  (use-package vertico-prescient
    :after (vertico prescient)
    :config
    (vertico-prescient-mode 1)) 
#+end_src

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode 1)) 
#+end_src

#+begin_src emacs-lisp :tangle no
  (use-package yasnippet
    :config
    (yas-global-mode 1)) 
#+end_src

** TODO Global keybindings
#+begin_src emacs-lisp
  (use-package general
    :after evil
    :config
    (general-evil-setup t)
    (general-override-mode 1)
    (general-create-definer gmap
      :keymaps 'override
      :states '(motion normal visual)
      :prefix "SPC")
    (general-create-definer lmap
      :keymaps 'override
      :states '(motion normal visual)
      :prefix ","))
#+end_src

#+begin_src emacs-lisp
  (mmap                                           ; Motion map
    "^" 'dired-jump) 
#+end_src

#+begin_src emacs-lisp
  (vmap                                           ; Visual map
    "ii" 'er/expand-region) 
#+end_src

#+begin_src emacs-lisp
  (gmap                                           ; Space menu
    "SPC" '(execute-extended-command :which-key "cmd")
    "1" '(tab-bar-select-tab :which-key "1")
    "2" '(tab-bar-select-tab :which-key "2")
    "3" '(tab-bar-select-tab :which-key "3")
    "4" '(tab-bar-select-tab :which-key "4")
    "5" '(tab-bar-select-tab :which-key "5")
    "6" '(tab-bar-select-tab :which-key "6")
    "7" '(tab-bar-select-tab :which-key "7")
    "8" '(tab-bar-select-tab :which-key "8")
    "9" '(tab-bar-select-tab :which-key "9")
    "b" '(switch-to-buffer :which-key "buffer")
    "d" '(dired-jump :which-key "dired")
    "f" '(find-file :which-key "file")
    "g" '(magit :which-key "git")
    "h" `(,help-map :which-key "help")
    "i" '(imenu :which-key "imenu")
    "j" '(bookmark-jump :which-key "jump")
    "k" '(kill-current-buffer :which-key "kill")
    "n" `(,narrow-map :which-key "narrow")
    "o" '(ace-window :which-key "other")
    "p" `(,project-prefix-map :which-key "project")
    "q" '(delete-window :which-key "quit window")
    "Q" '(tab-close :which-key "quit tab")
    "r" '(recentf :which-key "recent")
    "s" '(save-buffer :which-key "save")
    "t" '(tab-bar-new-tab :which-key "tab")
    "w" `(,evil-window-map :which-key "window")
    "y" '(clone-indirect-buffer-other-window :which-key "indirect")) 
#+end_src


#+begin_src emacs-lisp
  (lmap                                           ; Major modes
    "," (general-key "C-c C-c")
    "a" (general-key "C-c C-a")
    "b" (general-key "C-c C-b")
    "c" (general-key "C-c C-c")
    "d" (general-key "C-c C-d")
    "e" (general-key "C-c C-e")
    "f" (general-key "C-c C-f")
    "g" (general-key "C-c C-g")
    "h" (general-key "C-c C-h")
    "i" (general-key "C-c C-i")
    "j" (general-key "C-c C-j")
    "k" (general-key "C-c C-k")
    "l" (general-key "C-c C-l")
    "m" (general-key "C-c C-m")
    "n" (general-key "C-c C-n")
    "o" (general-key "C-c C-o")
    "p" (general-key "C-c C-p")
    "q" (general-key "C-c C-q")
    "r" (general-key "C-c C-r")
    "s" (general-key "C-c C-s")
    "t" (general-key "C-c C-t")
    "u" (general-key "C-c C-u")
    "v" (general-key "C-c C-v")
    "w" (general-key "C-c C-w")
    "x" (general-key "C-c C-x")
    "y" (general-key "C-c C-y")
    "z" (general-key "C-c C-z")) 
#+end_src

#+begin_src emacs-lisp
  (lmap                                           ; Minor modes
    "!"  (general-key "C-c !" )
    "\"" (general-key "C-c \"")
    "#"  (general-key "C-c #" )
    "$"  (general-key "C-c $" )
    "%"  (general-key "C-c %" )
    "&"  (general-key "C-c &" )
    "'"  (general-key "C-c '" )
    "("  (general-key "C-c (" )
    ")"  (general-key "C-c )" )
    "*"  (general-key "C-c *" )
    "+"  (general-key "C-c +" )
    "-"  (general-key "C-c -" )
    "."  (general-key "C-c ." )
    "/"  (general-key "C-c /" )
    ":"  (general-key "C-c :" )
    ";"  (general-key "C-c ;" )
    "<"  (general-key "C-c <" )
    "="  (general-key "C-c =" )
    ">"  (general-key "C-c >" )
    "?"  (general-key "C-c ?" )
    "@"  (general-key "C-c @" )
    "["  (general-key "C-c [" )
    "\\" (general-key "C-c \\")
    "]"  (general-key "C-c ]" )
    "^"  (general-key "C-c ^" )
    "_"  (general-key "C-c _" )
    "`"  (general-key "C-c `" )
    "{"  (general-key "C-c {" )
    "|"  (general-key "C-c |" )
    "}"  (general-key "C-c }" )
    "~"  (general-key "C-c ~" ))
#+end_src

* [0%] Custom modes
** TODO Monospace-mode
One of the reasons I've kept going back to Emacs in the terminal for a while, is that I really like my editor buffers to respect the monospace grid. Somehow, I find it easier to edit documents using the keyboard only if the document uses a single face (no proportional fonts), size (no huge headings), and single base line (i.e. no real superscripts/subscripts). Many themes and packages tend to make these things a bit too fancy for my liking, and playing whack-a-mole with config options to reverse it is no fun. I therefore want an automated way to use a single mono font everywhere in the Emacs GUI, while retaining the nice things a GUI offers (e.g. =pdf-view=, =xenops-mode=, =comint-mime=).

Probably just a habit from nearly 2 decades as a Vim user... I like proportional fonts and real superscripts when /reading/ documents, just not when /writing/ or /editing/ them.

Also disables italics by default, even though they're monospace. I somehow find monospace italics very hard to read compared to proportional italics.

Here is some code generated by ChatGPT 4. I'll have to clean it up and can then consider wrapping it as a package later. If so, consider making each property customizable (disable variable-pitch, italics, variable height).
#+begin_src emacs-lisp
  (defun my-customize-faces ()
    "Customize all faces to be non-italic, use the default font family, and have the same font size."
    (interactive)
    (let ((default-height (face-attribute 'default :height)))
      (mapcar
       (lambda (face)
         (when (facep face)
           (set-face-attribute face nil :slant 'normal)
           (set-face-attribute face nil :family 'unspecified)
           (set-face-attribute face nil :height default-height)))
       (face-list))
      (set-face-attribute 'variable-pitch nil
                          :inherit 'default
                          :family 'unspecified
                          :slant 'normal
                          :height default-height)))

  (defun my-reapply-custom-faces (&rest _)
    "Reapply custom faces after loading a theme."
    (when my-custom-faces-mode
      (my-customize-faces)))

  (define-minor-mode my-custom-faces-mode
    "A minor mode to apply custom face settings."
    :lighter " MyFaces"
    :global t
    (if my-custom-faces-mode
        (progn
          (my-customize-faces)
          (advice-add 'load-theme :after #'my-reapply-custom-faces))
      (advice-remove 'load-theme #'my-reapply-custom-faces)
      (message "My custom faces mode disabled")))

  ;; Enable the minor mode by default
  (my-custom-faces-mode 1)
#+end_src
* TODO Theming
#+begin_src emacs-lisp
  ;; Use a nicer theme.
  (load-theme 'modus-operandi-tinted t)
#+end_src
* DONE Profiling
It is a continuous project to keep Emacs fast and lean. Monitoring the start-up time is a good way to start, but I might consider adopting things like the [[https://github.com/jschaf/esup][Emacs Start Up Profiler]] if things get too much out of hand.
#+begin_src emacs-lisp
  (defun +init-time ()
    "Print the Emacs start-up time in milliseconds."
    (interactive)
    (message (emacs-init-time "Emacs init time: %.2f s")))
  (add-hook 'emacs-startup-hook #'+init-time)
#+end_src

* DONE Tangle
This little snippet of code ensures that every time I save my =config.org= notebook from within Emacs, it automatically exports the embedded code blocks to the appropriate files: =init.el=, =early-init.el=, etc.
#+begin_src
  Local Variables:
    eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
  End:
#+end_src
  
